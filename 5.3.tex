\subsection{二叉树的遍历和线索二叉树}\qanswerloc{161}

\begin{qitems}

    \begin{bbox}
        \qitem 若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？
    \end{bbox}
    
    \begin{bbox}
        \qitem 若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？
    \end{bbox}

    \begin{bbox}
        \qitem 假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。
    \end{bbox}

    \begin{bbox}
        \qitem 二叉树按二叉链表形式存储，试编写一个判别给定二叉树是否是完全二叉树的算法。
    \end{bbox}

    \begin{bbox}
        \qitem 假设二叉树采用二叉链表存储结构存储，试设计一个算法，计算一棵给定二叉树的所有双分支结点个数。
    \end{bbox}
    
    \begin{bbox}
        \qitem 设树 B 是一棵采用链式结构存储的二叉树，编写一个把树 B 中所有结点的左、右子树进行交换的函数。
    \end{bbox}

    \begin{bbox}
        \qitem 假设二叉树采用二叉链表存储结构存储，设计一个算法，求先序遍历序列中第 $k$ ($1 \le k \le$ 二叉树中结点个数) 个结点的值。
    \end{bbox}

    \begin{bbox}
        \qitem 已知二叉树以二叉链表存储，编写算法完成：对于树中每个元素值为 $x$ 的结点，删除以它为根的子树，并释放相应的空间。
    \end{bbox}

    \begin{bbox}
        \qitem 在二叉树中查找值为 $x$ 的结点，试编写算法（用 C 语言）打印值为 $x$ 的结点的所有祖先，假设值为 $x$ 的结点不多于一个。
    \end{bbox}

    \begin{bbox}
        \qitem 设一棵二叉树的结点结构为 (LLINK, INFO, RLINK)，ROOT 为指向该二叉树根结点的指针，$p$ 和 $q$ 分别为指向该二叉树中任意两个结点的指针，试编写算法 ANCESTOR(ROOT, $p, q, r$)，找到 $p$ 和 $q$ 的最近公共祖先结点 $r$。
    \end{bbox}

    \begin{bbox}
        \qitem 假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树 $b$ 的宽度（具有结点数最多的那一层的结点个数）。
    \end{bbox}

    \begin{bbox}
        \qitem 设有一棵满二叉树（所有结点值均不同），已知其先序序列为 \textit{pre}，设计一个算法求其后序序列 \textit{post}。
    \end{bbox}

    \begin{bbox}
        \qitem 设计一个算法将二叉树的叶结点按从左到右的顺序连成一个单链表，表头指针为 \texttt{head}。二叉树按二叉链表方式存储，链接时用叶结点的右指针域来存放单链表指针。
    \end{bbox}

    \begin{bbox}
        \qitem 试设计判断两棵二叉树是否相似的算法。所谓二叉树 $T_1$ 和 $T_2$ 相似，指的是 $T_1$ 和 $T_2$ 都是空的二叉树或都只有一个根结点；或者 $T_1$ 的左子树和 $T_2$ 的左子树是相似的，且 $T_1$ 的右子树和 $T_2$ 的右子树是相似的。
    \end{bbox}

    \begin{bbox}
        \qitem 【2014 统考真题】二叉树的带权路径长度 (WPL) 是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树 $T$，采用二叉链表存储，结点结构为
        \begin{center}
            \begin{tabular}{|c|c|c|}
            \hline
            \texttt{left} & \texttt{weight} & \texttt{right} \\
            \hline
            \end{tabular}
        \end{center}
        其中叶结点的 \texttt{weight} 域保存该结点的非负权值。设 \texttt{root} 为指向 $T$ 的根结点的指针，请设计求 $T$ 的 WPL 的算法，要求：
        \begin{subqitems}
            \subqitem 给出算法的基本设计思想。
            \subqitem 使用 C 或 C++语言，给出二叉树结点的数据类型定义。
            \subqitem 根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。
        \end{subqitems}
    \end{bbox}

    \begin{bbox}
        \qitem 【2017 统考真题】请设计一个算法，将给定的表达式树 (二叉树) 转换为等价的中缀表达式 (通过括号反映操作符的计算次序) 并输出。例如，当下列两棵表达式树作为算法的输入时：
        
        \begin{center}
            \begin{forest}
              for tree={circle, draw, s sep=10mm, l sep=5mm,},
              [*,
                [+,
                  [a]
                  [b]
                ]
                [*,
                  [c]
                  [-,
                    [,phantom]
                    [d]
                  ]
                ]
              ]
            \end{forest}
            \hspace{2cm}
            \begin{forest}
              for tree={circle, draw, s sep=15mm, l sep=8mm,},
              [+,
                [*,
                  [a]
                  [b]
                ]
                [-,
                  [-,
                    [c]
                    [d]
                  ]
                ]
              ]
            \end{forest}
        \end{center}
        
        输出的等价中缀表达式分别为 \texttt{(a+b)*(c*(-d))} 和 \texttt{(a*b)+(-(c-d))}。
        
        二叉树结点定义如下：
        \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
typedef struct node{
    char data[10];      // 存储操作数或操作符
    struct node *left, *right;
}BTree;
        \end{lstlisting}
        要求：
        \begin{subqitems}
            \subqitem 给出算法的基本设计思想。
            \subqitem 根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。
        \end{subqitems}
    \end{bbox}

    \begin{bbox}
        \qitem 【2022 统考真题】已知非空二叉树 $T$ 的结点值均为正整数，采用顺序存储方式保存，数据结构定义如下：
        \begin{lstlisting}[language=C, basicstyle=\ttfamily\small]
typedef struct {              //MAX_SIZE 为已定义常量
    int SqBiTNode[MAX_SIZE];  //保存二叉树结点值的数组
    int ElemNum;              //实际占用的数组元素个数
} SqBiTree;
        \end{lstlisting}
        $T$ 中不存在的结点在数组 \texttt{SqBiTNode} 中用 -1 表示。例如，对于下图所示的两棵非空二叉树 $T_1$ 和 $T_2$：
        
        \begin{center}
            \begin{minipage}{0.45\linewidth}
                \centering
                \begin{forest}
                  for tree={circle, draw, l sep=8mm},
                  [40,
                    [25,
                      [, phantom]
                      [30,
                        [27]
                        [, phantom]
                      ]
                    ]
                    [60,
                      [, phantom]
                      [80]
                    ]
                  ]
                \end{forest}
                \\ 二叉树 $T_1$
            \end{minipage}
            \begin{minipage}{0.45\linewidth}
                \centering
                \begin{forest}
                  for tree={circle, draw, l sep=10mm, s sep=5mm},
                  [40,
                    [50,
                      [, phantom]
                      [30,
                        [, phantom]
                        [35]
                      ]
                    ]
                    [60]
                  ]
                \end{forest}
                \\ 二叉树 $T_2$
            \end{minipage}
        \end{center}
        
        \noindent $T_1$ 的存储结果如下： \\
        \texttt{T1.SqBiTNode} \hspace{1cm}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
        \hline
        40 & 25 & 60 & -1 & 30 & -1 & 80 & -1 & -1 & 27 \\
        \hline
        \end{tabular} \\
        \texttt{T1.ElemNum=10}
    
        \vspace{5mm}
    
        \noindent $T_2$ 的存储结果如下： \\
        \texttt{T2.SqBiTNode} \hspace{1cm}
        \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
        40 & 50 & 60 & -1 & 30 & -1 & -1 & -1 & -1 & -1 & 35 \\
        \hline
        \end{tabular} \\
        \texttt{T2.ElemNum=11}
    
        \vspace{5mm}
    
        \noindent 请设计一个尽可能高效的算法，判定一棵采用这种方式存储的二叉树是否为二叉搜索树，若是，则返回 \texttt{true}，否则，返回 \texttt{false}。要求：
        \begin{subqitems}
            \subqitem 给出算法的基本设计思想。
            \subqitem 根据设计思想，采用 C 或 C++语言描述算法，关键之处给出注释。
        \end{subqitems}
    \end{bbox}

\end{qitems} 